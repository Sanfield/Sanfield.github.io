<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[http头总结]]></title>
    <url>%2F2019%2F03%2F05%2Fhttp%E5%A4%B4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Expires 相应头包含日期/时间，即在此之后，响应过气（如果有cache-controle响应头设置了‘max-age’或者‘s-max-age’指令，那么Expires被忽略） Date 通用首部，报文的创建时间和日期 Age消息头包含消息对象在缓存中存贮的时长，以秒为单位 IF-Modified-Since 是一个条件请求首部，服务器只在请求资源在给定的日期时间之后对内容进行修改的情况下才将资源返回，状态码为200。如果请求资源从那时起未经修改，那么返回一个不带有消息主体的304相应，而在Last-Modified首部中会有上次修改时间，不同于IF-Unmodified-Since，if-Modified-Since 只能用在GET和HEAD请求中。与IF-None-Match一同出现时，IF-Modified-Since会被忽略，除非服务器不支持IF-None-Match DNT 0:用户愿意目标站点追踪用户个人信息;1:用户不愿意目标站点追踪用户个人信息 Cache-Control控制缓存 缓存请求指令 缓存响应指令 Transfer-Encoding 用于指定传输方法 chunked 数据以分块的形式发送 compress (LZW)压缩算法 deflate 采用zlib结构和deflate压缩算法 gzip gip压缩 identity 自身（未经压缩和修改） ETag 资源标记的版本，类似于签名，以便客户端使用缓存还是更新 X-Fframe-Option 三个值 Deny 不允许在fram中展示 sameOrigin 相同域名页面的frame中展示 allow-from uri 表示页面可以在指定来源的fram中展示]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web页面集成高德地图]]></title>
    <url>%2F2019%2F03%2F02%2Fweb%E9%A1%B5%E9%9D%A2%E9%9B%86%E6%88%90%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[今天因为领导角色用户自己手工收入位置不好校验正确性，并不友好。决定做一个类似于外卖定位的地图组建。 获取用户的输入，进行模糊匹配 在地图上定位，并标记 用户选区标记，返回位置坐标 保存到数据库 12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="initial-scale=1.0, user-scalable=no, width=device-width"&gt; &lt;title&gt;位置更新&lt;/title&gt; &lt;link rel="stylesheet" href="https://cache.amap.com/lbs/static/main1119.css"/&gt; &lt;script src="../jquery/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="https://webapi.amap.com/maps?v=1.4.13&amp;key=自己的key&amp;plugin=AMap.Autocomplete,AMap.PlaceSearch"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="https://cache.amap.com/lbs/static/addToolbar.js"&gt;&lt;/script&gt; &lt;script src="../js/map.js"&gt;&lt;/script&gt;&lt;style&gt; #map&#123; width: 500px; height: 300px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;input type="text" id="tipinput" placeholder="请输入关键字"/&gt; &lt;input type="text" id="lnglat" placeholder=""/&gt; &lt;input type="text" id="address" placeholder=""/&gt;&lt;/div&gt;&lt;div id="map"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 页面主要是定义地图所装载的容器，引入高德地图所需的文件。js文件主要用来获取用户 数据，和获取用户标记事件 123456789101112131415161718192021222324252627$(function () &#123; //地图加载 var map = new AMap.Map("map", &#123; resizeEnable: true &#125;);//输入提示 var autoOptions = &#123; input: "tipinput" &#125;; var auto = new AMap.Autocomplete(autoOptions); var placeSearch = new AMap.PlaceSearch(&#123; map: map &#125;); //构造地点查询类 AMap.event.addListener(auto, "select", select);//注册监听，当选中某条记录时会触发 function select(e) &#123; placeSearch.setCity(e.poi.adcode); placeSearch.search(e.poi.name); //关键字查询查询 &#125;//点击事件 AMap.event.addListener(placeSearch, "markerClick", function(e) &#123; console.log(e.data.location);//当前marker的经纬度信息 document.getElementById("lnglat").value = e.data.location.lng + ',' + e.data.location.lat; console.log(e.data.address);//获取当前marker的具体地址信息 console.log(e.data);//则是包含所有的marker数据 document.getElementById("address").value = e.data.pname+e.data.cityname+e.data.adname+e.data.address+e.data.name; &#125;);&#125;);]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql表明大小写敏感问题]]></title>
    <url>%2F2019%2F02%2F28%2Fmysql%E8%A1%A8%E6%98%8E%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[mysql表名大小写敏感解决方法： 找到mysql配置文件 my.cnf 在[mysqld]节点下添加lower-case-table-names=0 重启mysql服务]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归构造树形菜单]]></title>
    <url>%2F2019%2F02%2F28%2F%E9%80%92%E5%BD%92%E6%9E%84%E9%80%A0%E6%A0%91%E5%BD%A2%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[后台主要是在关系型数据库中拼接为树形的数据结构。递归遍历如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160package com.merit.common;import com.alibaba.fastjson.JSONArray;import java.util.ArrayList;import java.util.List;public class TreeBuilder &#123; List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); public JSONArray buildTree(List&lt;Node&gt; nodes) &#123; TreeBuilder treeBuilder = new TreeBuilder(nodes); return treeBuilder.buildJSONTree(); &#125; public TreeBuilder() &#123; &#125; public TreeBuilder(List&lt;Node&gt; nodes) &#123; super(); this.nodes = nodes; &#125; // 构建JSON树形结构 public JSONArray buildJSONTree() &#123; List&lt;Node&gt; nodeTree = buildTree(); JSONArray jsonArray = JSONArray.parseArray(JSONArray.toJSONString(nodeTree)); return jsonArray; &#125; // 构建树形结构 public List&lt;Node&gt; buildTree() &#123; List&lt;Node&gt; treeNodes = new ArrayList&lt;&gt;(); List&lt;Node&gt; rootNodes = getRootNodes(); for (Node rootNode : rootNodes) &#123; buildChildNodes(rootNode); treeNodes.add(rootNode); &#125; return treeNodes; &#125; // 递归子节点 public void buildChildNodes(Node node) &#123; List&lt;Node&gt; children = getChildNodes(node); if (!children.isEmpty()) &#123; for (Node child : children) &#123; buildChildNodes(child); &#125; node.setNodes(children); &#125; &#125; // 获取父节点下所有的子节点 public List&lt;Node&gt; getChildNodes(Node pnode) &#123; List&lt;Node&gt; childNodes = new ArrayList&lt;&gt;(); for (Node n : nodes) &#123; if (pnode.getHref().equals(n.getSjdwbm())) &#123; childNodes.add(n); &#125; &#125; return childNodes; &#125; // 判断是否为根节点 public boolean rootNode(Node node) &#123; boolean isRootNode = true; for (Node n : nodes) &#123; if(node.getSjdwbm()!=null)&#123; if (node.getSjdwbm().equals(n.getHref())) &#123; isRootNode = false; break; &#125; &#125; &#125; return isRootNode; &#125; // 获取集合中所有的根节点 public List&lt;Node&gt; getRootNodes() &#123; List&lt;Node&gt; rootNodes = new ArrayList&lt;&gt;(); for (Node n : nodes) &#123; if (rootNode(n)) &#123; rootNodes.add(n); &#125; &#125; return rootNodes; &#125; public static class Node &#123; private String href; //单位编码 private String sjdwbm; //上级单位编码 private String text; //单位名称 private String dwlx;//单位类型 private String dwjb;//单位级别 private List&lt;Node&gt; nodes; public Node() &#123; &#125; public String getDwlx() &#123; return dwlx; &#125; public void setDwlx(String dwlx) &#123; this.dwlx = dwlx; &#125; public String getDwjb() &#123; return dwjb; &#125; public void setDwjb(String dwjb) &#123; this.dwjb = dwjb; &#125; public Node(String href, String sjdwbm, String text) &#123; super(); this.href = href; this.sjdwbm = sjdwbm; this.text = text; &#125; public String getHref() &#123; return href; &#125; public void setHref(String href) &#123; this.href = href; &#125; public String getSjdwbm() &#123; return sjdwbm; &#125; public void setSjdwbm(String sjdwbm) &#123; this.sjdwbm = sjdwbm; &#125; public String getText() &#123; return text; &#125; public void setText(String text) &#123; this.text = text; &#125; public List&lt;Node&gt; getNodes() &#123; return nodes; &#125; public void setNodes(List&lt;Node&gt; nodes) &#123; this.nodes = nodes; &#125; &#125;&#125; 在controller层的调用如下: 1234567891011 @ResponseBody @RequestMapping(&quot;/getTree&quot;) public JSONObject getTree()&#123;// 获取全部目录节点 List&lt;TreeBuilder.Node&gt; nodes = userService.selecTreeNode(); JSONObject josn = new JSONObject(); // 拼装树形json字符串 JSONArray str = new TreeBuilder().buildTree(nodes); josn.put(&quot;list&quot;,str); return josn; &#125;]]></content>
      <categories>
        <category>递归</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios的配置和使用]]></title>
    <url>%2F2019%2F01%2F28%2Faxios%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[这几天大佬让我把项目的ajax全部换成axois，接到任务时，我内心深处第一反应是两个字**,因为由于历史问题…..。哎，程序员怎么能说不能，干吧。之前只是了解过，但是也没实际用过，趁着这次也用用。在网上找了找，发现并不复杂。来吧，照着官网来。 安装 npm install axios 引用 import axios from ‘axios’ 挂载在vue原型上 Vue.proptotype.$axios=axois; 调用12345this.$axios.get('xxxxx').then(res=&gt;&#123; //TODO&#125;).catch(err=&gt;console.log(err)); 到目前，我们的axios已经可以成功运行了，尝试发了一个请求，已经能接受到请求了。接下来就是 做一些利国利民的事情了。 设置基本路径 axios.defaults.baseURL=’http://sanfield.github.io&#39; 设置拦截器 请求发起之前 1234567891011// 定义拦截器// 1: 请求发起前显示loading open();Axios.interceptors.request.use(function(config) &#123; // 不变配置: 可变，可以设置公共的请求头操作 MintUI.Indicator.open(&#123; text: '玩儿命加载中...', spinnerType: 'fading-circle' &#125;); // console.log(config); return config; // config:&#123; headers&#125;&#125;) 接收到相应后123456789// 2: 响应回来后关闭loading close()Axios.interceptors.response.use(function(response) &#123; //reponse: &#123; config:&#123; &#125;,data:&#123;&#125; ,headers &#125; // 接收响应头或者响应体中的数据，保存起来，供请求的拦截器中使用头信息操作 MintUI.Indicator.close(); // console.log(response); return response;&#125;) 经过上面一系列操作，我们的axios已经可以进行生产使用了，好了我要挨个解决历史问题了。]]></content>
      <categories>
        <category>ES6</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reactNative基础3]]></title>
    <url>%2F2019%2F01%2F10%2FreactNative%E5%9F%BA%E7%A1%803%2F</url>
    <content type="text"><![CDATA[元素对其方式元素对其方式就是元素相对于父元素的位置，默认情况下元素在纵轴的最上边，横轴的最左边，不过通过样式可以改变元素在父容器的位置。 12345// 主轴对其方式justifyContent: flex-start flex-end center space-between space-around// 交叉轴对其方式alignItems: flex-start flex-end center stretch 1234567891011121314151617181920212223242526272829303132333435export default class FlexAlignTest extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;View style=&#123;styles.one&#125;&gt;&lt;/View&gt; &lt;View style=&#123;styles.two&#125;&gt;&lt;/View&gt; &lt;View style=&#123;styles.three&#125;&gt;&lt;/View&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, width: 500, justifyContent: "center", alignItems: "center" &#125;, one: &#123; height: 100, width: 100, backgroundColor: "red" &#125;, two: &#123; height: 100, width: 100, backgroundColor: "green" &#125;, three: &#123; height: 100, width: 100, backgroundColor: "blue" &#125;&#125;); feachRN提供了和web标准一致的网络请求API，XMLHttpRequest与Fetch，Fetch用起来将对比较容易，且支持Promise，所以一般会选用Fetch。 12// 豆瓣电影top250: http://api.douban.com/v2/movie/top250// 豆瓣电影详情: http://api.douban.com/v2/movie/top250/movie/subject/:id 发起一个get请求 12fetch('http://api.douban.com/v2/movie/top250').then((response) =&gt; console.log(response)); 发起一个post请求，并携带参数，需要使用Fetch第二个options参数 123456789fetch('http://api.douban.com/v2/movie/top250', &#123; method: 'POST', headers: &#123; 'Accept': 'application/json', 'Content-Type': 'application/json', &#125;, body: JSON.stringify(&#123;a:1, b:2&#125;)&#125;).then((response) =&gt; console.log(response)); fetch返回的Promise对象，添加的成功回调拿到的是response对象，里面的数据默认是文本，一般我们请求回来的数据是json对象，可以使用response对象提供的json方法转换，该转换方法同样返回一个Promise对象，所以一般我们需要两次then，在第二个then里拿到对象数据。 12345678fetch('http://api.douban.com/v2/movie/top250').then((response) =&gt; response.json()).then((responseJson) =&gt; &#123; console.log(responseJson);&#125;).catch((error) =&gt; &#123; console.error(error);&#125;);]]></content>
      <categories>
        <category>es6</category>
        <category>react-natives</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reactNative基础2]]></title>
    <url>%2F2019%2F01%2F07%2FreactNative%E5%9F%BA%E7%A1%802%2F</url>
    <content type="text"><![CDATA[StyleSheet 所有RN中的样式都必须用这个Api创建 所有样式名称都必须是驼峰命名 RN中所有的组件默认display属性都是flex，而且主轴方向是column 每个元素可以通过数组设置多种样式，如果遇到相同的样式，后面样式的优先级大于前面 12345678const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: '#fff', alignItems: 'center', justifyContent: 'center', &#125;,&#125;); 盒子模型在RN中的元素同样拥有盒子模型：宽高、内边距、边框、外边距。 需要注意在RN中的样式大小不需要单位，同时没有css的复合样式，比如border、background、font，在RN中border宽度、颜色、圆角等样式需要一个一个设置，background和font也一样。 关于padding与margin，在css中可以赋予多个值来设置四边不一样的大小，在RN中只能给定一个值，指定相同的大小，如果四边大小不一样，就需要按照方向一个一个设置。同时RN也提供了paddingHorizontal、marginHorizontal、paddingVertical、marginVertical同时设置左右和上下两个方向的值。 另外补充一下，在设置字体时，Android内建的有这么几个: normal、serif、monospace 1234567891011121314151617181920212223242526272829303132333435import React, &#123; Component &#125; from "react";import &#123; StyleSheet, View, Text &#125; from "react-native";export default class StyleBoxTest extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &#123;/* 通过margin和父盒子产生距离 */&#125; &lt;View style=&#123;styles.box&#125;&gt; &#123;/* 文本受到了父盒子padding的影响 */&#125; &lt;Text&gt;内容&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;&#125;let styles = StyleSheet.create(&#123; container: &#123; width: 500, height: 500, backgroundColor: "blue" &#125;, box: &#123; width: 300, height: 300, paddingHorizontal: 10, paddingVertical: 80, backgroundColor: "red", borderWidth: 10, borderRadius: 10, borderColor: "yellow", margin: 30, marginLeft: 50 &#125;&#125;); 弹性布局ReactNative中组件默认采用flex弹性布局，使用flex可以使其在可利用的空间中动态地扩张或收缩，ReactNative中的flex工作原理和web上的CSS基本一致，当然也存在少许差异。首先是默认值不同：flexDirection的默认值是column而不是row，而flex也只能指定一个数字值。 主轴方向采用flex弹性布局的容器，子元素有横纵两种排列方式，在ReactNative中默认是纵向的，也就是说默认元素呈纵向排列，如果有需要也可以通过flexDireaction样式进行修改。 12345678910111213141516171819202122232425export default class FlexDirectionTest extends Component &#123; render() &#123; return ( &lt;View&gt; &#123;/* 默认情况下元素纵向排列 */&#125; &lt;View&gt; &lt;View&gt;&lt;Text&gt;123&lt;/Text&gt;&lt;/View&gt; &lt;View&gt;&lt;Text&gt;456&lt;/Text&gt;&lt;/View&gt; &lt;/View&gt; &#123;/* 改为横向排列 */&#125; &lt;View style=&#123;styles.row&#125;&gt; &lt;View&gt;&lt;Text&gt;123&lt;/Text&gt;&lt;/View&gt; &lt;View&gt;&lt;Text&gt;456&lt;/Text&gt;&lt;/View&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;&#125;let styles = StyleSheet.create(&#123; row: &#123; // flexDirection: row row-reverse column column-reverse flexDirection: "row", &#125;&#125;); 弹性宽高一般而言我们会使用flex:1来指定某个组件扩张以撑满所有剩余的空间。如果有多个并列的子组件使用了flex:1，则这些子组件会平分父容器中剩余的空间。如果这些并列的子组件的flex值不一样，则谁的值更大，谁占据剩余空间的比例就更大。 123456789101112131415161718192021222324252627282930export default class FlexSizeTest extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;View style=&#123;styles.one&#125;&gt;&lt;/View&gt; &lt;View style=&#123;styles.two&#125;&gt;&lt;/View&gt; &lt;View style=&#123;styles.three&#125;&gt;&lt;/View&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; // 父容器必须有大小子元素才能分配宽高 container: &#123; flex: 1, &#125;, one: &#123; flex: 1, backgroundColor: "red" &#125;, two: &#123; flex: 2, backgroundColor: "green" &#125;, three: &#123; flex: 3, backgroundColor: "blue" &#125;&#125;); 弹性宽高补充组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的width和height，也没有设定flex，则父容器的尺寸为零。其子组件如果使用了flex，也是无法显示的。在一个组件中，如果父容器设置方向为纵，那么子元素必须设置高度或flex占比，否则盒子无大小。在一个组件中，如果父容器设置方向为横，那么子元素必须设置宽度或flex占比，否则盒子无大小。 12345678910111213141516171819202122232425262728293031323334353637383940414243export default class FlexSize2Test extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;View style=&#123;styles.one&#125;&gt;&lt;/View&gt; &lt;View style=&#123;styles.two&#125;&gt;&lt;/View&gt; &lt;View style=&#123;styles.three&#125;&gt; &lt;View style=&#123;styles.threeOne&#125;&gt;&lt;/View&gt; &lt;View style=&#123;styles.threeTwo&#125;&gt;&lt;/View&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, flexDirection: "row" &#125;, // 如果父容器设置方向为横，那么子元素必须设置宽度或flex，否则盒子无大小 one: &#123; flex: 1, backgroundColor: "red" &#125;, two: &#123; width: 200, backgroundColor: "green" &#125;, three: &#123; flex: 3, backgroundColor: "blue", &#125;, // 如果父容器设置方向为纵，那么子元素必须设置高度或flex占比，否则盒子无大小。 threeOne: &#123; flex: 1, backgroundColor: "yellow" &#125;, threeTwo: &#123; height: 300, backgroundColor: "orange" &#125;&#125;);]]></content>
      <categories>
        <category>es6</category>
        <category>react-natives</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reactNative基础组件]]></title>
    <url>%2F2019%2F01%2F03%2FreactNative%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[内置组件 在 React Native 中你需要使用官方提供的组件进行应用构建 因为是开发原生应用, 我们的代码最终会转为原生组件的方式渲染, 所以你不会看到任何以 html 标签命名的组件 [官方文档] https://facebook.github.io/react-native/docs/getting-started View 视图容器，作用相当于 html 的 div 标签，它是创建UI所需的最基础组件，支持Flexbox布局、样式、触摸事件，它可以放到其它视图中，也可以包含任意多个任意子视图。 https://reactnative.cn/docs/view/ 12345678910111213141516171819202122232425262728293031323334import React, &#123; Component &#125; from 'react';import &#123; StyleSheet, View, Text, Button &#125; from 'react-native';export default class ViewTest extends Component &#123; render() &#123; return ( &#123;/* View标签相当于div，可以嵌套 */&#125; &lt;View style=&#123;style.container&#125;&gt; &lt;View&gt; &lt;Text&gt;React Native&lt;/Text&gt; &lt;/View&gt; &lt;View&gt; &lt;Text&gt;使用React编写&lt;/Text&gt; &lt;Text&gt;使用JSX编写&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;&#125;// 注意border、background等样式不能简写，必须一个一个的设置属性let style = StyleSheet.create(&#123; container: &#123; width: 300, padding: 10, borderStyle: "dashed", borderWidth: 2, borderColor: "red", borderRadius: 2, &#125;, text: &#123; fontSize: 20, color: "yellow", &#125;&#125;); Text 文本容器，作用相当于 html 的 span 标签，为什么不是 p 标签呢，一会演示。Text标签支持嵌套、触摸事件。在RN中，文本必须放置到Text中才可以被渲染，否则报错。 注意: 除了Text外, 别的组件内都不能包含文本 https://reactnative.cn/docs/text/ 文本布局 Text采用的是文本布局，多个子文本在渲染时会折叠合并在一起，如果把View理解成块级元素，那么Text就可以理解为行内元素。 123456789101112131415import React, &#123; Component &#125; from "react";import &#123; StyleSheet, View, Text &#125; from "react-native";export default class TextTest extends Component &#123; render() &#123; return ( // 可以嵌套 &lt;Text&gt; &lt;Text&gt;饿了吗&lt;/Text&gt; &lt;Text&gt;美图&lt;/Text&gt; &lt;/Text&gt; ); &#125;&#125; 文本样式 在RN中，父文本的样式可以传递给后代文本，也就是样式继承。但是除了文本之外其它组件都无法继承样式。 1234567891011121314151617181920render() &#123; return ( &lt;Text style=&#123;style.rootText&#125;&gt; &lt;Text&gt;饿了吗&lt;/Text&gt; &lt;Text&gt;美图&lt;/Text&gt; &#123;/* 文本样式继承 */&#125; &lt;Text&gt; &lt;Text&gt;滴滴外卖&lt;/Text&gt; &lt;/Text&gt; &lt;/Text&gt; );&#125;let style = StyleSheet.create(&#123; rootText: &#123; fontSize: 20, color: "blue", lineHeight: 24 &#125;&#125;);]]></content>
      <categories>
        <category>es6</category>
        <category>react-natives</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速搭建RN开发环境]]></title>
    <url>%2F2019%2F01%2F01%2F%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BARN%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[ReactNative 快速开始学习使用 ReactNative 最令人头疼的就是环境问题，因为大多数 Web 开发者，并不熟悉 Android 与 IOS 的开发环境，配置起来比较繁琐。当然 Android 程序员也不熟悉 IOS 环境，反之亦然，这导致很多人因为繁杂的开发环境而放弃学习或者暂时搁浅。 为了改善这个问题，一个快速的开发环境解决方案应运而生。这个方案需要两个工具：1. create-react-native-app 2. Expo。 create-react-native-app这是一款用来创建 ReactNative 项目的脚手架工具。特点是无需配置繁杂的 Android 或 IOS 开发环境，便可进行原生应用的开发，极大简化了环境搭建与配置的过程，很适合学习使用。 [参考文档] https://reactnative.cn/docs/getting-started.html [替代方案] https://facebook.github.io/react-native/docs/getting-started.html 安装12345# 安装npm install -g create-react-native-app# 检测，文档更新时最新版本2.0.2create-react-native-app --version 使用123456# 创建项目create-react-native-app projectName# 启动项目cd projectNameexpo start Expo这是一款安装在手机上的应用，专门负责运行上述方式构建的 App，这有点像是微信里面运行的小程序。IOS 可以到 AppStore 里面搜索下载，Android 可以到 GooglePlay 里面搜索下载，也可以到 Github 里下载。 [Github] https://github.com/expo/expo 真机运行准备工作：使用create-react-native-app创建一个项目，然后手机安装Expo应用，并确保手机与开发机处于同一局域网下。 项目运行：npm start启动项目，打开Expo应用，使用里面的扫一扫功能，扫描项目启动后生成的巨大二维码，等待JS打包传输完毕，就会在手机上运行。 IP错误问题因为开发机可能会有多个ip地址，比如以太网IP、虚拟IP、无线局域网IP等等。当项目启动时通常会无脑的选择IP列表中的第一个，假如是以太网IP，那么就与手机所处的无线局域网不同，造成网络连接失败。 下面是这种情况的图例，项目启动时使用的是IP列表中的第一个94 IP，并没有使用无线局域网IP。 如果发生这种情况，先Ctrl+C停掉项目，设置一个环境变量，然后再重启项目即可。 [参考解决方案] https://github.com/react-community/create-react-native-app/blob/d01ddabb634532200629c6d17f920eb856fa6416/react-native-scripts/template/README.md#environment-variables [参考解决方案] https://github.com/react-community/create-react-native-app/issues/270 12345# 设置环境变量set REACT_NATIVE_PACKAGER_HOSTNAME=my-custom-ip-address-or-hostname# 重启项目npm start 开发初体验 在项目根目录下有个 App.js , 是应用的根组件, 我们手机上看到的内容就是这个组件实现的 尝试修改 App.js 中的文本内容, 然后手机摇一摇, 点击 Reload 选项即可更新修改内容 也可尝试给文本添加新的样式 12345678910111213141516171819202122232425import React from 'react';import &#123; StyleSheet, Text, View &#125; from 'react-native';// 导出根组件, 组件的定于语法与之前学习的一样export default class App extends React.Component &#123; render() &#123; return ( // 返回的视图需要使用View组件包裹, 作用相当于Div标签 &lt;View style=&#123;styles.container&#125;&gt; &#123;/* 文本内容使用Text组件包裹, 作用相当于P标签 */&#125; &lt;Text&gt;Open up App.js to start working on your app!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;// 定义样式, 这里的尺寸大小无需加单位, 元素可以通过数组引用多个样式, 后面的样式优先级比前面的高const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: '#fff', alignItems: 'center', justifyContent: 'center', &#125;,&#125;); 错误提示 - 红屏和黄屏RN代码运行时会把错误分为红屏和黄屏两种，红屏会以全屏红色显示在应用中，导致程序无法正常运行，红屏通常是编码错误导致的，必须修复。 黄屏代表警告，会显示在应用下方，不影响程序运行，不修复也可以，警告可以通过代码禁止。 红屏和黄屏只在debug版本中才会显示，在rellease版本中不会。一般情况下，通过RN红屏中的错误提示信息，就可以定位问题，如果是语法等常见运行错误，RN也会给出错误代码所在位置与行数，所以出现红屏一定要阅读描述信息。 123456// 频闭黄色警告，参数为一个数组：数组中的字符串就是要屏蔽的警告的开头的内容。YellowBox.ignoreWarnings(['Warning: ']);// 手动触发红屏和警告console.error("严重错误");console.warn("警告"); 调试菜单React-Native开发调试没有本地代码方便，但也是可以调的，在调试菜单中可以进行开发调试相关的配置。调试菜单只在debug版本中可以被调出，如果是模拟器环境，Windows平台按window+m可调出，也可能是F1或F2，Mac平台按commond+m可调出，或者发送adb shell input keyevent 82指令。如果是真机，摇一摇就可以调出调试菜单。 调试菜单说明 Reload: 重新加载整个页面 Debug JS Remotely: 启动远程调试, 会自动打开chrome浏览器, 然后可在开发者工具中调试js Enable Live Reload: 开启自动加载, 代码变动会自动更新整个页面 Enable Hot Reloading: 热更新, 代码变动自动的进行局部更新 Dev Sttings: 开发调试配置]]></content>
      <categories>
        <category>es6</category>
        <category>react-natives</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode二叉树]]></title>
    <url>%2F2018%2F12%2F05%2Fleetcode%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树的前序便利给定一个二叉树，返回它的 前序 遍历。 示例: 输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,2,3] 12345678910111213141516import java.util.ArrayList;class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; ArrayList&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;(); if(root==null)return res; order(root,res); return res; &#125; private static void order(TreeNode root, ArrayList&lt;Integer&gt; list)&#123; if(root != null)&#123; list.add(root.val); order(root.left,list); order(root.right,list); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode2两个链表之和]]></title>
    <url>%2F2018%2F12%2F02%2Fleetcode2%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 我的思路 这道题因为不知道链表的长度，所以在计算时不能用转换成int的方式进行计算。这样的可能会造成溢出。 加法其实就是 相同位再加进位数，进行循环就好，直到两个链表都为null，就标志着相加完成。 talk is cheap show me code 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @Author: sangfei * @Description: */public class LeetCode2 &#123; public static void main(String[] args)&#123; &#125; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; if(l1==null)&#123; return l2; &#125; if(l2==null)&#123; return l1; &#125; ListNode dummyHead=new ListNode(0); ListNode curr=dummyHead; int res=0;//进位 while (l1!=null || l2!=null)&#123; int x=(l1!=null)?l1.val:0; int y=(l2!=null)?l2.val:0; int sum=x+y+res; res=sum/10; curr.next= new ListNode(sum%10); curr=curr.next; if(l1!=null) l1=l1.next; if(l2!=null) l2=l2.next; &#125; if(res&gt;0)&#123; curr.next=new ListNode(res); &#125; return dummyHead.next; &#125;&#125; class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode[1]两数之和]]></title>
    <url>%2F2018%2F12%2F01%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[从今天开始从新学习一遍数据结构，并开始leetcode学习之旅给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。示例: 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]思路： 暴力破解时间复杂度为O(N*N) 哈希表时间复杂度为O(N)下面是我的个人写法，仅作参考。123456789101112131415public class TowSum &#123; public int[] twoSum(int[] numbers, int target) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int[] result= new int[2]; for(int i=0;i&lt;numbers.length;i++)&#123; if(map.get(target-numbers[i])!=null)&#123; result[0]= map.get(target-numbers[i])+1; result[1]=i+1; &#125;else&#123; map.put(numbers[i],i); &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动实现jquery2]]></title>
    <url>%2F2018%2F11%2F18%2F%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0jquery2%2F</url>
    <content type="text"><![CDATA[仔细看了看，上次的jquery源码不太对，jquery的作者并不是这样写的，原谅我的不仔细。这样写的话如果获取到dom元素后，在加$().css,等方法时，会造成一个极大的内存浪费。源码是这样的12345678910111213141516171819202122232425262728293031(function(global)&#123; function jQuery(selector)&#123; return new jQuery.fn.init(selector); &#125; jQuery.fn = jQuery.prototype = &#123; constructor:jQuery, init:function(selector)&#123; if(jQuery.type(selector)==="string")&#123; //选择器 const elements = document.querySelectorAll(selector) for(let i = 0;i&lt;elements.length;i++)&#123; this[i] = elements[i]; &#125; this.length=elements.length; &#125;else if( selector.nodeType )&#123; //DOM元素 this[0] = selector; this.length = 1; &#125; &#125; &#125; jQuery.fn.init.prototype = jQuery.fn; global.$ = global.jQuery = jQuery;&#125;)(window)]]></content>
      <categories>
        <category>javascript</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS日期相加减]]></title>
    <url>%2F2018%2F11%2F17%2FJS%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%8A%A0%E5%87%8F%2F</url>
    <content type="text"><![CDATA[Js中时间相加减因为有时候从后台传过来的时间，不能直接进行运算。所以我们需要进行格式转化后进行相加减。我后台的格式如下： yyyy-mm-dd hh24:mi后在前台需要进行如下转换:12345678910var dayTime=updateTime.split(" "); var day=dayTime[0].split("-"); var time=dayTime[1].split(":"); var oldTime=new Date(Number(day[0]),(Number(day[1])-1),Number(day[2]),Number(time[0]),Number(time[1]),0); var newTime= new Date(); var iDays = Math.floor((newTime - oldTime) / 86400000); if(iDays&gt;5)&#123; mx.indicate ("info", "只能撤回发布5天之内的方案！"); return; &#125; 如上是连个日期相减，日期加的话在新日期生成的时候直接在构造函数内相加。下面是日期加五天的例子：1var newime=new Date(Number(day[0]),(Number(day[1])+5),Number(day[2]),Number(time[0]),Number(time[1]),0);]]></content>
      <categories>
        <category>-Javascript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>格式转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动实现jquery]]></title>
    <url>%2F2018%2F11%2F17%2F%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0jquery%2F</url>
    <content type="text"><![CDATA[目前jQuery生存空间越来越小，但是在实际的生产项目由于历史遗留问题jquery仍然被大量使用。这几天在歇息时仔细看看了它的实现，发现里面还是有很多值得我学习的地方，对理解js基础知识以及编程思路有很大的帮助。 首先jq它为我们只提供了一个JQuery和$两个入口函数，并且在加载完后就能引用，所以最外层肯定和其他框架一样是一个立即执行函数。看代码123456(function(windown)&#123; function jQuery(selector)&#123; &#125; window.$ = window.jQuery = jQuery;&#125;)(windown) 这样就可以给用户提供一个jQuery函数了，并且把选择器当成参数传进去 函数内部拿到了选择器，接下来就要拿到 dom对象，然后改变对象的属性了。Jquery并没有在Jquery函数中直接获取，而是在另外一个函数获取。具体看代码1234567891011121314151617181920(function(window)&#123; function Fn(selector)&#123; &#125; Fn.prototype = &#123; init(selector)&#123; var elements = document.querySelectorAll(selector); for( var i = 0 ; i &lt; elements.length ; i++ )&#123; this[i] = elements[i]; this.length++; &#125; &#125;, length : 0 &#125; function jQuery(selector)&#123; return new Fn(selector) &#125; window.$ = window.jQuery = jQuery; &#125;)(window) 怎么样是不是很巧妙，这样就可以在函数内部形成高内聚和不浪费运行内存的形式。]]></content>
      <categories>
        <category>javascript</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMD和CMD]]></title>
    <url>%2F2018%2F11%2F15%2FAMD%E5%92%8CCMD%2F</url>
    <content type="text"><![CDATA[#AMD CMD，CommonJs和ES6的区别 AMDAMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出requireJS主要解决两个问题: 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长看一个使用requireJS的例子： 12345678910111213141516//定义模块MyModuledefine(['dependency'], function()&#123; var name = 'Byron'; function printName()&#123; console.log(name); &#125; return &#123; printName: printName &#125;;&#125;);// 加载模块require(['myModule'], function (my)&#123; my.printName();&#125;); 语法： requireJS定义了一个函数 define，它是全局变量，用来定义模块define(id?, dependencies?, factory);id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）dependencies：是一个当前模块依赖的模块名称数组factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值在页面上使用require函数加载模块 require([dependencies], function(){});require()函数接受两个参数第一个参数是一个数组，表示所依赖的模块第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。 CMD(Common Module Definition)淘宝团队提供，就近依赖，同步概念即用即加载模块 12345678910// 定义模块 myModule.jsdefine(function(require, exports, module) &#123; var $ = require('jquery.js') $('div').addClass('active');&#125;);// 加载模块seajs.use(['myModule.js'], function(my)&#123;&#125;); CommonJs规范，module.exprts与nodeJs采用的规范一致话不多说，上代码： 1234567exports.area=function(r)&#123; return Math.PI*r*r;&#125;exports.circumference=function(r)&#123; return 2*Math.PI*r;&#125; ES6特性 export/import成对出现，有导出才有导入 12345678910111213141516//lib.js//导出常量export const sqrt = Math.sqrt;//导出函数export function square(x) &#123; return x * x;&#125;//导出函数export function diag(x, y) &#123; return sqrt(square(x) + square(y));&#125;//main.jsimport &#123; square, diag &#125; from './lib';console.log(square(11)); // 121console.log(diag(4, 3)); // 5]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的数据交互]]></title>
    <url>%2F2018%2F11%2F01%2FJSONP%E5%92%8Curlencode%2F</url>
    <content type="text"><![CDATA[这几天在项目中用到的一些数据传输问题 ajax cors跨域cors跨域很简单，也是官方推荐的方法1response.setHeader(“Access-Control-Allow-Origin”, “*”); CORS方案实现非常简单，只要服务在头部标明允许跨域访问即可。但是这个方案由于推出时间较晚，所以IE9及以下浏览器并没有支持这个机制。IE9及以下浏览器在安全设置里控制是否允许跨域数据访问： JOSNPjosnp 属于民间开发者自己搞的方法，其原理是 动态创建srcipt标签支持目前所有浏览器，只是在实现方式上需要前后端代码有一点约定配合。但是，要注意由于JSONP是以script标签的src属性加载的，因此参数会收到URL长度的限制，只能适用于传入参数内容不多的场景。典型应用：百度搜索输入框获取下拉框 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; function show(data)&#123; alert(data.s); &#125; window.onload=function()&#123; let oTxt= document.getElementById("in"); oTxt.oninput=function()&#123; let secrpt= document.createElement('script'); secrpt.src=`https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=$&#123;encodeURIComponent(oTxt.value)&#125;&amp;cb=show` document.head.appendChild(secrpt); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" name="" id="in"&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Javascript</category>
        <category>数据交互</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>XHR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win-server升级mysql]]></title>
    <url>%2F2018%2F10%2F13%2Fwin-server%E5%8D%87%E7%BA%A7mysql%2F</url>
    <content type="text"><![CDATA[先备份原来的数据库在mysql的安装目录下 cd bin执行:mysqldump -uroot -p –all-databases &gt; sqlfile.sql输入密码:可以在bin目录下找到sqlfile.sql文件，保存该文件。 安装1.下载地址：https://dev.mysql.com/downloads/mysql/5.7.html#2.下载后可以把解压的内容随便放到一个目录，我的是如下目录（放到C盘的话，可能在修改ini文件时涉及权限问题，之后我就改放E盘了）：E:\mysql如下图：此时加压后的文件中没有data目录和ini文件3.在E:\mysql目录下新建my.ini文件，复制如下内容[mysqld]设置3306端port = 3306设置mysql的安装目录basedir=E:\mysql设置mysql数据库的数据的存放目录datadir=E:\mysql\data允许最大连接数max_connections=200服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8创建新表时将使用的默认存储引擎default-storage-engine=INNODBsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES[mysql]设置mysql客户端默认字符集default-character-set=ut]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js闭包]]></title>
    <url>%2F2018%2F10%2F10%2Fjs%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[12345678910function a()&#123; var i=0; function b()&#123; console.log(++i); &#125; return b;&#125;var c=a();c(); 这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b，就是说：当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。 闭包的作用 在a执行完后并返回，闭包使得JavaScript的垃圾回收机制GC不会收回a所占的资源，因为a的内部函数b的执行需要依赖a中的变量下面是一个经典的闭包利用12345678910111213for(var j=0;j&lt;5;j++)&#123; (function(j)&#123; setTimeout(function()&#123; console.log(j); &#125;,1000); &#125;)(j)&#125;console.log(`--------------`);for(var i=0;i&lt;=5;i++)&#123; ((i)=&gt;&#123;setTimeout(()=&gt; console.log(i),1000); &#125;)(i);&#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动实现ajax]]></title>
    <url>%2F2018%2F08%2F06%2F%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0ajax%2F</url>
    <content type="text"><![CDATA[代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function ajax(option)&#123; option=option||&#123;&#125;; option.type=option.type||'get'; option.data=option.data||&#123;&#125;; option.dataType=option.dataType||'text'; let xhr=new XMLHttpRequest(); let arr=[]; for(let name in option.data)&#123; arr.push(`$&#123;encodeURIComponent(name)&#125;=$&#123;encodeURIComponent(option.data[name])&#125;`); &#125; let strData=arr.join('&amp;'); if(option.type=='post')&#123; xhr.open('POST',option.url,true); xhr.setRequestHeader('content-type','application/x-www-form-urlencoded'); xhr.send(strData); &#125;else&#123; xhr.open('GET',option.url+'?'+strData,true); xhr.send(); &#125; //接收 xhr.onreadystatechange=()=&gt;&#123; if(xhr.readyState==4)&#123; if(xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300 ||xhr.status==304)&#123; let data=xhr.responseText; switch(option.dataType)&#123; case 'json': if(window.JSON &amp;&amp; JSON.parse)&#123; data=JSON.parse(data); &#125;else&#123; data=eval('('+str+')'); &#125; break; case 'xml': data=xhr.responseXML; break; &#125; option.success &amp;&amp; option.success(data); &#125;else&#123; options.error &amp;&amp; options.error(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Javascript</category>
        <category>数据交互</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>XHR</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Spring-Eurka]]></title>
    <url>%2F2018%2F07%2F08%2F%E5%88%9D%E8%AF%86Spring-Eurka%2F</url>
    <content type="text"><![CDATA[服务治理是微服务中核心和基础的模块，主要用来实现给每个微服务的自动化注册与发现 服务注册：将自己的服务在注册中心进行登记（例如uap中把application.properties中 12345#------------------------------------------------注册中心配置--------------------------------------#注册中心地址eureka.client.serviceUrl.defaultZone=http://127.0.0.1:8761/eureka/#优先识别通过ip地址访问注册中心的请求？eureka.instance.preferIpAddress=true ） 服务发现 ：每当一个服务发起调用时，注册中心以某种轮训的策略取出一个位置来进行服务调用，这就后期牵扯到客服端的负载均衡 高可用的注册中心Eureka.client 的高可用实际上就是讲自己作为服务向其他服务中心注册自己，这样就可以形成一组相互注册的服务注册中心，实现服务清单互相同步，这样就构成了一个双节点的服务注册中心集群 123456eureka.instance.hostname=peer1eureka.client.serviceUrl.defaultZone=xxxx(另外一个注册中心的地址)在peer2 中eureka.instance.hostname=peer2eureka.client.serviceUrl.defaultZone=xxxx(另外一个注册中心的地址)]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[boostrap-table分页排序]]></title>
    <url>%2F2018%2F06%2F01%2Fboostrap-table%E5%88%86%E9%A1%B5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[boostrap-table分页有两种，一种是利用fommart函数的index参数，进行自增参数。这种的简单易操作，适用于序号仅表示行号的情况。 123456field: '',title: '序号',align:"center",formatter:function (value,row,index) &#123; return index+1;&#125; 但是在某些情况下可能需要分页后页码依然连续，这在boostrap-table本事是无法进行实现的，所以需要自定义方法。 首先当前序号=（pageNum-1）*pageSize+index $(‘#tableId’).bootstrapTable(‘getOptions’).pageSize 根据getOptions属性能获取到当前的pageSize，和pageNum；123456789101112&#123; field: 'number', title: '序号', width:5 , align:'center', switchable:false, formatter:function(value,row,index)&#123; //return index+1; //序号正序排序从1开始 var pageSize=$('#tableId').bootstrapTable('getOptions').pageSize;//通过表的#id 可以得到每页多少条 var pageNumber=$('#tableId').bootstrapTable('getOptions').pageNumber;//通过表的#id 可以得到当前第几页 return pageSize * (pageNumber - 1) + index + 1; //返回每条的序号： 每页条数 * （当前页 - 1 ）+ 序号 &#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>boostrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[boostrap-tree的使用]]></title>
    <url>%2F2018%2F05%2F30%2Fboostrap-tree%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[初始化树:12345678910var treeData= getTreeData();console.log(treeData);$(&apos;#treeview1&apos;).treeview(&#123; // backColor: &quot;#FFFFFF&quot;, color: &quot;#428bca&quot;, // enableLinks: true, showBorder:false, data: treeData&#125;); 其中 treeData必须的属性必须有text 要显示的内容,href 为主键,nodes: 是该列的所有子节点]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>boostrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[boostrap-tree的默认选中]]></title>
    <url>%2F2018%2F05%2F30%2Fboostrap-tree%E7%9A%84%E9%BB%98%E8%AE%A4%E9%80%89%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[1$(&apos;#searchTree&apos;).treeview(&apos;checkNode&apos;,Number($(&quot;#&quot;+id+&quot;&quot;).attr(&apos;data-nodeid&apos;)),&#123;silent:true&#125;); 这个idtreeview自动分配的id,不容易获得所以修改boostrap-treeviw的源码在bootstrap-treeview.js找到:1node.nodeId = _this.nodes.length; 添加: 12//自己添加的nodeId node.id=node.id; 第二步:找到: 1var treeItem = $(_this.template.item) 在对象里添加: 1.attr(&apos;id&apos;, node.id) 这样再次审查树的元素时，就会发现多了一个属性id]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>boostrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[boosrtap-table动态设置高]]></title>
    <url>%2F2018%2F05%2F28%2Fboosrtap-table%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE%E9%AB%98%2F</url>
    <content type="text"><![CDATA[动态设置高，对不齐问题一般在使用BootstrapTable 插件的时候，我是不固定高度的，没有height属性时候的插件一切正常，表格对齐也没有问题。但是为了将页面撑开，使数据少的时候，页面不显得空荡，所以就固定了高度： height: $(window).height()*0.79 根据页面的大小进行动态变化。此时就会出现表格不对齐的现象，解决方法：打开bootstrap-table.js 找到 BootstrapTable.prototype.resetView方法，找到如下代码： 123456if (this.options.showHeader &amp;&amp; this.options.height) &#123; this.$tableHeader.show(); //注释掉下面两行 取消表头初始化解决表头和内容不对齐问题 //this.resetHeader(); //padding += this.$header.outerHeight();&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>boostrap</tag>
      </tags>
  </entry>
</search>
