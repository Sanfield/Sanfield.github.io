<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F01%2F19%2F1%2F</url>
    <content type="text"><![CDATA[var reg =/./; console.log( reg.test('a'));]]></content>
  </entry>
  <entry>
    <title><![CDATA[手动实现jquery]]></title>
    <url>%2F2019%2F01%2F17%2F%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0jquery%2F</url>
    <content type="text"><![CDATA[目前jQuery生存空间越来越小，但是在实际的生产项目由于历史遗留问题jquery仍然被大量使用。这几天在歇息时仔细看看了它的实现，发现里面还是有很多值得我学习的地方，对理解js基础知识以及编程思路有很大的帮助。 首先jq它为我们只提供了一个JQuery和$两个入口函数，并且在加载完后就能引用，所以最外层肯定和其他框架一样是一个立即执行函数。看代码123456(function(windown)&#123; function jQuery(selector)&#123; &#125; window.$ = window.jQuery = jQuery;&#125;)(windown) 这样就可以给用户提供一个jQuery函数了，并且把选择器当成参数传进去 函数内部拿到了选择器，接下来就要拿到 dom对象，然后改变对象的属性了。Jquery并没有在Jquery函数中直接获取，而是在另外一个函数获取。具体看代码1234567891011121314151617181920(function(window)&#123; function Fn(selector)&#123; &#125; Fn.prototype = &#123; init(selector)&#123; var elements = document.querySelectorAll(selector); for( var i = 0 ; i &lt; elements.length ; i++ )&#123; this[i] = elements[i]; this.length++; &#125; &#125;, length : 0 &#125; function jQuery(selector)&#123; return new Fn(selector) &#125; window.$ = window.jQuery = jQuery; &#125;)(window) 怎么样是不是很巧妙，这样就可以在函数内部形成高内聚和不浪费运行内存的形式。]]></content>
      <categories>
        <category>javascript</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动实现jquery2]]></title>
    <url>%2F2018%2F11%2F18%2F%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0jquery2%2F</url>
    <content type="text"><![CDATA[仔细看了看，上次的jquery源码不太对，jquery的作者并不是这样写的，原谅我的不仔细。这样写的话如果获取到dom元素后，在加$().css,等方法时，会造成一个极大的内存浪费。源码是这样的12345678910111213141516171819202122232425262728293031(function(global)&#123; function jQuery(selector)&#123; return new jQuery.fn.init(selector); &#125; jQuery.fn = jQuery.prototype = &#123; constructor:jQuery, init:function(selector)&#123; if(jQuery.type(selector)==="string")&#123; //选择器 const elements = document.querySelectorAll(selector) for(let i = 0;i&lt;elements.length;i++)&#123; this[i] = elements[i]; &#125; this.length=elements.length; &#125;else if( selector.nodeType )&#123; //DOM元素 this[0] = selector; this.length = 1; &#125; &#125; &#125; jQuery.fn.init.prototype = jQuery.fn; global.$ = global.jQuery = jQuery;&#125;)(window)]]></content>
      <categories>
        <category>javascript</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS日期相加减]]></title>
    <url>%2F2018%2F11%2F17%2FJS%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%8A%A0%E5%87%8F%2F</url>
    <content type="text"><![CDATA[Js中时间相加减因为有时候从后台传过来的时间，不能直接进行运算。所以我们需要进行格式转化后进行相加减。我后台的格式如下： yyyy-mm-dd hh24:mi后在前台需要进行如下转换:12345678910var dayTime=updateTime.split(" "); var day=dayTime[0].split("-"); var time=dayTime[1].split(":"); var oldTime=new Date(Number(day[0]),(Number(day[1])-1),Number(day[2]),Number(time[0]),Number(time[1]),0); var newTime= new Date(); var iDays = Math.floor((newTime - oldTime) / 86400000); if(iDays&gt;5)&#123; mx.indicate ("info", "只能撤回发布5天之内的方案！"); return; &#125; 如上是连个日期相减，日期加的话在新日期生成的时候直接在构造函数内相加。下面是日期加五天的例子：1var newime=new Date(Number(day[0]),(Number(day[1])+5),Number(day[2]),Number(time[0]),Number(time[1]),0);]]></content>
      <categories>
        <category>-Javascript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>格式转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMD和CMD]]></title>
    <url>%2F2018%2F11%2F15%2FAMD%E5%92%8CCMD%2F</url>
    <content type="text"><![CDATA[#AMD CMD，CommonJs和ES6的区别 AMDAMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出requireJS主要解决两个问题: 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长看一个使用requireJS的例子： 12345678910111213141516//定义模块MyModuledefine(['dependency'], function()&#123; var name = 'Byron'; function printName()&#123; console.log(name); &#125; return &#123; printName: printName &#125;;&#125;);// 加载模块require(['myModule'], function (my)&#123; my.printName();&#125;); 语法： requireJS定义了一个函数 define，它是全局变量，用来定义模块define(id?, dependencies?, factory);id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）dependencies：是一个当前模块依赖的模块名称数组factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值在页面上使用require函数加载模块 require([dependencies], function(){});require()函数接受两个参数第一个参数是一个数组，表示所依赖的模块第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。 CMD(Common Module Definition)淘宝团队提供，就近依赖，同步概念即用即加载模块 12345678910// 定义模块 myModule.jsdefine(function(require, exports, module) &#123; var $ = require('jquery.js') $('div').addClass('active');&#125;);// 加载模块seajs.use(['myModule.js'], function(my)&#123;&#125;); CommonJs规范，module.exprts与nodeJs采用的规范一致话不多说，上代码： 1234567exports.area=function(r)&#123; return Math.PI*r*r;&#125;exports.circumference=function(r)&#123; return 2*Math.PI*r;&#125; ES6特性 export/import成对出现，有导出才有导入 12345678910111213141516//lib.js//导出常量export const sqrt = Math.sqrt;//导出函数export function square(x) &#123; return x * x;&#125;//导出函数export function diag(x, y) &#123; return sqrt(square(x) + square(y));&#125;//main.jsimport &#123; square, diag &#125; from './lib';console.log(square(11)); // 121console.log(diag(4, 3)); // 5]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的数据交互]]></title>
    <url>%2F2018%2F11%2F01%2FJSONP%E5%92%8Curlencode%2F</url>
    <content type="text"><![CDATA[这几天在项目中用到的一些数据传输问题 ajax cors跨域cors跨域很简单，也是官方推荐的方法1response.setHeader(“Access-Control-Allow-Origin”, “*”); CORS方案实现非常简单，只要服务在头部标明允许跨域访问即可。但是这个方案由于推出时间较晚，所以IE9及以下浏览器并没有支持这个机制。IE9及以下浏览器在安全设置里控制是否允许跨域数据访问： JOSNPjosnp 属于民间开发者自己搞的方法，其原理是 动态创建srcipt标签支持目前所有浏览器，只是在实现方式上需要前后端代码有一点约定配合。但是，要注意由于JSONP是以script标签的src属性加载的，因此参数会收到URL长度的限制，只能适用于传入参数内容不多的场景。典型应用：百度搜索输入框获取下拉框 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; function show(data)&#123; alert(data.s); &#125; window.onload=function()&#123; let oTxt= document.getElementById("in"); oTxt.oninput=function()&#123; let secrpt= document.createElement('script'); secrpt.src=`https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=$&#123;encodeURIComponent(oTxt.value)&#125;&amp;cb=show` document.head.appendChild(secrpt); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" name="" id="in"&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Javascript</category>
        <category>数据交互</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>XHR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win-server升级mysql]]></title>
    <url>%2F2018%2F10%2F13%2Fwin-server%E5%8D%87%E7%BA%A7mysql%2F</url>
    <content type="text"><![CDATA[先备份原来的数据库在mysql的安装目录下 cd bin执行:mysqldump -uroot -p –all-databases &gt; sqlfile.sql输入密码:可以在bin目录下找到sqlfile.sql文件，保存该文件。 安装1.下载地址：https://dev.mysql.com/downloads/mysql/5.7.html#2.下载后可以把解压的内容随便放到一个目录，我的是如下目录（放到C盘的话，可能在修改ini文件时涉及权限问题，之后我就改放E盘了）：E:\mysql如下图：此时加压后的文件中没有data目录和ini文件3.在E:\mysql目录下新建my.ini文件，复制如下内容[mysqld]设置3306端port = 3306设置mysql的安装目录basedir=E:\mysql设置mysql数据库的数据的存放目录datadir=E:\mysql\data允许最大连接数max_connections=200服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8创建新表时将使用的默认存储引擎default-storage-engine=INNODBsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES[mysql]设置mysql客户端默认字符集default-character-set=ut]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js闭包]]></title>
    <url>%2F2018%2F10%2F10%2Fjs%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[12345678910function a()&#123; var i=0; function b()&#123; console.log(++i); &#125; return b;&#125;var c=a();c(); 这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b，就是说：当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。 闭包的作用 在a执行完后并返回，闭包使得JavaScript的垃圾回收机制GC不会收回a所占的资源，因为a的内部函数b的执行需要依赖a中的变量下面是一个经典的闭包利用12345678910111213for(var j=0;j&lt;5;j++)&#123; (function(j)&#123; setTimeout(function()&#123; console.log(j); &#125;,1000); &#125;)(j)&#125;console.log(`--------------`);for(var i=0;i&lt;=5;i++)&#123; ((i)=&gt;&#123;setTimeout(()=&gt; console.log(i),1000); &#125;)(i);&#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajxa]]></title>
    <url>%2F2018%2F10%2F06%2Fajxa%2F</url>
    <content type="text"><![CDATA[对编写]]></content>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动实现ajax]]></title>
    <url>%2F2018%2F08%2F06%2F%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0ajax%2F</url>
    <content type="text"><![CDATA[代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function ajax(option)&#123; option=option||&#123;&#125;; option.type=option.type||'get'; option.data=option.data||&#123;&#125;; option.dataType=option.dataType||'text'; let xhr=new XMLHttpRequest(); let arr=[]; for(let name in option.data)&#123; arr.push(`$&#123;encodeURIComponent(name)&#125;=$&#123;encodeURIComponent(option.data[name])&#125;`); &#125; let strData=arr.join('&amp;'); if(option.type=='post')&#123; xhr.open('POST',option.url,true); xhr.setRequestHeader('content-type','application/x-www-form-urlencoded'); xhr.send(strData); &#125;else&#123; xhr.open('GET',option.url+'?'+strData,true); xhr.send(); &#125; //接收 xhr.onreadystatechange=()=&gt;&#123; if(xhr.readyState==4)&#123; if(xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300 ||xhr.status==304)&#123; let data=xhr.responseText; switch(option.dataType)&#123; case 'json': if(window.JSON &amp;&amp; JSON.parse)&#123; data=JSON.parse(data); &#125;else&#123; data=eval('('+str+')'); &#125; break; case 'xml': data=xhr.responseXML; break; &#125; option.success &amp;&amp; option.success(data); &#125;else&#123; options.error &amp;&amp; options.error(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Javascript</category>
        <category>数据交互</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>XHR</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
