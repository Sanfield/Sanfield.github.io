<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常见的数据交互]]></title>
    <url>%2F2018%2F11%2F01%2FJSONP%E5%92%8Curlencode%2F</url>
    <content type="text"><![CDATA[这几天在项目中用到的一些数据传输问题 ajax cors跨域cors跨域很简单，也是官方推荐的方法1response.setHeader(“Access-Control-Allow-Origin”, “*”); CORS方案实现非常简单，只要服务在头部标明允许跨域访问即可。但是这个方案由于推出时间较晚，所以IE9及以下浏览器并没有支持这个机制。IE9及以下浏览器在安全设置里控制是否允许跨域数据访问： JOSNPjosnp 属于民间开发者自己搞的方法，其原理是 动态创建srcipt标签支持目前所有浏览器，只是在实现方式上需要前后端代码有一点约定配合。但是，要注意由于JSONP是以script标签的src属性加载的，因此参数会收到URL长度的限制，只能适用于传入参数内容不多的场景。典型应用：百度搜索输入框获取下拉框 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; function show(data)&#123; alert(data.s); &#125; window.onload=function()&#123; let oTxt= document.getElementById("in"); oTxt.oninput=function()&#123; let secrpt= document.createElement('script'); secrpt.src=`https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=$&#123;encodeURIComponent(oTxt.value)&#125;&amp;cb=show` document.head.appendChild(secrpt); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" name="" id="in"&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Javascript</category>
        <category>数据交互</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>XHR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win-server升级mysql]]></title>
    <url>%2F2018%2F10%2F13%2Fwin-server%E5%8D%87%E7%BA%A7mysql%2F</url>
    <content type="text"><![CDATA[先备份原来的数据库在mysql的安装目录下 cd bin执行:mysqldump -uroot -p –all-databases &gt; sqlfile.sql输入密码:可以在bin目录下找到sqlfile.sql文件，保存该文件。 安装1.下载地址：https://dev.mysql.com/downloads/mysql/5.7.html#2.下载后可以把解压的内容随便放到一个目录，我的是如下目录（放到C盘的话，可能在修改ini文件时涉及权限问题，之后我就改放E盘了）：E:\mysql如下图：此时加压后的文件中没有data目录和ini文件3.在E:\mysql目录下新建my.ini文件，复制如下内容[mysqld]设置3306端port = 3306设置mysql的安装目录basedir=E:\mysql设置mysql数据库的数据的存放目录datadir=E:\mysql\data允许最大连接数max_connections=200服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8创建新表时将使用的默认存储引擎default-storage-engine=INNODBsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES[mysql]设置mysql客户端默认字符集default-character-set=ut]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js闭包]]></title>
    <url>%2F2018%2F10%2F10%2Fjs%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[12345678910function a()&#123; var i=0; function b()&#123; console.log(++i); &#125; return b;&#125;var c=a();c(); 这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b，就是说：当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。 闭包的作用 在a执行完后并返回，闭包使得JavaScript的垃圾回收机制GC不会收回a所占的资源，因为a的内部函数b的执行需要依赖a中的变量下面是一个经典的闭包利用12345678910111213for(var j=0;j&lt;5;j++)&#123; (function(j)&#123; setTimeout(function()&#123; console.log(j); &#125;,1000); &#125;)(j)&#125;console.log(`--------------`);for(var i=0;i&lt;=5;i++)&#123; ((i)=&gt;&#123;setTimeout(()=&gt; console.log(i),1000); &#125;)(i);&#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajxa]]></title>
    <url>%2F2018%2F10%2F06%2Fajxa%2F</url>
    <content type="text"><![CDATA[对编写]]></content>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动实现ajax]]></title>
    <url>%2F2018%2F08%2F06%2F%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0ajax%2F</url>
    <content type="text"><![CDATA[代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function ajax(option)&#123; option=option||&#123;&#125;; option.type=option.type||'get'; option.data=option.data||&#123;&#125;; option.dataType=option.dataType||'text'; let xhr=new XMLHttpRequest(); let arr=[]; for(let name in option.data)&#123; arr.push(`$&#123;encodeURIComponent(name)&#125;=$&#123;encodeURIComponent(option.data[name])&#125;`); &#125; let strData=arr.join('&amp;'); if(option.type=='post')&#123; xhr.open('POST',option.url,true); xhr.setRequestHeader('content-type','application/x-www-form-urlencoded'); xhr.send(strData); &#125;else&#123; xhr.open('GET',option.url+'?'+strData,true); xhr.send(); &#125; //接收 xhr.onreadystatechange=()=&gt;&#123; if(xhr.readyState==4)&#123; if(xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300 ||xhr.status==304)&#123; let data=xhr.responseText; switch(option.dataType)&#123; case 'json': if(window.JSON &amp;&amp; JSON.parse)&#123; data=JSON.parse(data); &#125;else&#123; data=eval('('+str+')'); &#125; break; case 'xml': data=xhr.responseXML; break; &#125; option.success &amp;&amp; option.success(data); &#125;else&#123; options.error &amp;&amp; options.error(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Javascript</category>
        <category>数据交互</category>
      </categories>
      <tags>
        <tag>XHR</tag>
        <tag>ES6</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
