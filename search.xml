<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[axios的配置和使用]]></title>
    <url>%2F2019%2F01%2F28%2Faxios%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[这几天大佬让我把项目的ajax全部换成axois，接到任务时，我内心深处第一反应是两个字**,因为由于历史问题…..。哎，程序员怎么能说不能，干吧。之前只是了解过，但是也没实际用过，趁着这次也用用。在网上找了找，发现并不复杂。来吧，照着官网来。 安装 npm install axios 引用 import axios from ‘axios’ 挂载在vue原型上 Vue.proptotype.$axios=axois; 调用12345this.$axios.get('xxxxx').then(res=&gt;&#123; //TODO&#125;).catch(err=&gt;console.log(err)); 到目前，我们的axios已经可以成功运行了，尝试发了一个请求，已经能接受到请求了。接下来就是 做一些利国利民的事情了。 设置基本路径 axios.defaults.baseURL=’http://sanfield.github.io&#39; 设置拦截器 请求发起之前 1234567891011// 定义拦截器// 1: 请求发起前显示loading open();Axios.interceptors.request.use(function(config) &#123; // 不变配置: 可变，可以设置公共的请求头操作 MintUI.Indicator.open(&#123; text: '玩儿命加载中...', spinnerType: 'fading-circle' &#125;); // console.log(config); return config; // config:&#123; headers&#125;&#125;) 接收到相应后123456789// 2: 响应回来后关闭loading close()Axios.interceptors.response.use(function(response) &#123; //reponse: &#123; config:&#123; &#125;,data:&#123;&#125; ,headers &#125; // 接收响应头或者响应体中的数据，保存起来，供请求的拦截器中使用头信息操作 MintUI.Indicator.close(); // console.log(response); return response;&#125;) 经过上面一系列操作，我们的axios已经可以进行生产使用了，好了我要挨个解决历史问题了。]]></content>
      <categories>
        <category>ES6</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reactNative基础2]]></title>
    <url>%2F2019%2F01%2F07%2FreactNative%E5%9F%BA%E7%A1%802%2F</url>
    <content type="text"><![CDATA[StyleSheet 所有RN中的样式都必须用这个Api创建 所有样式名称都必须是驼峰命名 RN中所有的组件默认display属性都是flex，而且主轴方向是column 每个元素可以通过数组设置多种样式，如果遇到相同的样式，后面样式的优先级大于前面 12345678const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: '#fff', alignItems: 'center', justifyContent: 'center', &#125;,&#125;); 盒子模型在RN中的元素同样拥有盒子模型：宽高、内边距、边框、外边距。 需要注意在RN中的样式大小不需要单位，同时没有css的复合样式，比如border、background、font，在RN中border宽度、颜色、圆角等样式需要一个一个设置，background和font也一样。 关于padding与margin，在css中可以赋予多个值来设置四边不一样的大小，在RN中只能给定一个值，指定相同的大小，如果四边大小不一样，就需要按照方向一个一个设置。同时RN也提供了paddingHorizontal、marginHorizontal、paddingVertical、marginVertical同时设置左右和上下两个方向的值。 另外补充一下，在设置字体时，Android内建的有这么几个: normal、serif、monospace 1234567891011121314151617181920212223242526272829303132333435import React, &#123; Component &#125; from "react";import &#123; StyleSheet, View, Text &#125; from "react-native";export default class StyleBoxTest extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &#123;/* 通过margin和父盒子产生距离 */&#125; &lt;View style=&#123;styles.box&#125;&gt; &#123;/* 文本受到了父盒子padding的影响 */&#125; &lt;Text&gt;内容&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;&#125;let styles = StyleSheet.create(&#123; container: &#123; width: 500, height: 500, backgroundColor: "blue" &#125;, box: &#123; width: 300, height: 300, paddingHorizontal: 10, paddingVertical: 80, backgroundColor: "red", borderWidth: 10, borderRadius: 10, borderColor: "yellow", margin: 30, marginLeft: 50 &#125;&#125;); 弹性布局ReactNative中组件默认采用flex弹性布局，使用flex可以使其在可利用的空间中动态地扩张或收缩，ReactNative中的flex工作原理和web上的CSS基本一致，当然也存在少许差异。首先是默认值不同：flexDirection的默认值是column而不是row，而flex也只能指定一个数字值。 主轴方向采用flex弹性布局的容器，子元素有横纵两种排列方式，在ReactNative中默认是纵向的，也就是说默认元素呈纵向排列，如果有需要也可以通过flexDireaction样式进行修改。 12345678910111213141516171819202122232425export default class FlexDirectionTest extends Component &#123; render() &#123; return ( &lt;View&gt; &#123;/* 默认情况下元素纵向排列 */&#125; &lt;View&gt; &lt;View&gt;&lt;Text&gt;123&lt;/Text&gt;&lt;/View&gt; &lt;View&gt;&lt;Text&gt;456&lt;/Text&gt;&lt;/View&gt; &lt;/View&gt; &#123;/* 改为横向排列 */&#125; &lt;View style=&#123;styles.row&#125;&gt; &lt;View&gt;&lt;Text&gt;123&lt;/Text&gt;&lt;/View&gt; &lt;View&gt;&lt;Text&gt;456&lt;/Text&gt;&lt;/View&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;&#125;let styles = StyleSheet.create(&#123; row: &#123; // flexDirection: row row-reverse column column-reverse flexDirection: "row", &#125;&#125;); 弹性宽高一般而言我们会使用flex:1来指定某个组件扩张以撑满所有剩余的空间。如果有多个并列的子组件使用了flex:1，则这些子组件会平分父容器中剩余的空间。如果这些并列的子组件的flex值不一样，则谁的值更大，谁占据剩余空间的比例就更大。 123456789101112131415161718192021222324252627282930export default class FlexSizeTest extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;View style=&#123;styles.one&#125;&gt;&lt;/View&gt; &lt;View style=&#123;styles.two&#125;&gt;&lt;/View&gt; &lt;View style=&#123;styles.three&#125;&gt;&lt;/View&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; // 父容器必须有大小子元素才能分配宽高 container: &#123; flex: 1, &#125;, one: &#123; flex: 1, backgroundColor: "red" &#125;, two: &#123; flex: 2, backgroundColor: "green" &#125;, three: &#123; flex: 3, backgroundColor: "blue" &#125;&#125;); 弹性宽高补充组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的width和height，也没有设定flex，则父容器的尺寸为零。其子组件如果使用了flex，也是无法显示的。在一个组件中，如果父容器设置方向为纵，那么子元素必须设置高度或flex占比，否则盒子无大小。在一个组件中，如果父容器设置方向为横，那么子元素必须设置宽度或flex占比，否则盒子无大小。 12345678910111213141516171819202122232425262728293031323334353637383940414243export default class FlexSize2Test extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;View style=&#123;styles.one&#125;&gt;&lt;/View&gt; &lt;View style=&#123;styles.two&#125;&gt;&lt;/View&gt; &lt;View style=&#123;styles.three&#125;&gt; &lt;View style=&#123;styles.threeOne&#125;&gt;&lt;/View&gt; &lt;View style=&#123;styles.threeTwo&#125;&gt;&lt;/View&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, flexDirection: "row" &#125;, // 如果父容器设置方向为横，那么子元素必须设置宽度或flex，否则盒子无大小 one: &#123; flex: 1, backgroundColor: "red" &#125;, two: &#123; width: 200, backgroundColor: "green" &#125;, three: &#123; flex: 3, backgroundColor: "blue", &#125;, // 如果父容器设置方向为纵，那么子元素必须设置高度或flex占比，否则盒子无大小。 threeOne: &#123; flex: 1, backgroundColor: "yellow" &#125;, threeTwo: &#123; height: 300, backgroundColor: "orange" &#125;&#125;);]]></content>
      <categories>
        <category>es6</category>
        <category>react-natives</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速搭建RN开发环境]]></title>
    <url>%2F2019%2F01%2F01%2F%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BARN%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[ReactNative 快速开始学习使用 ReactNative 最令人头疼的就是环境问题，因为大多数 Web 开发者，并不熟悉 Android 与 IOS 的开发环境，配置起来比较繁琐。当然 Android 程序员也不熟悉 IOS 环境，反之亦然，这导致很多人因为繁杂的开发环境而放弃学习或者暂时搁浅。 为了改善这个问题，一个快速的开发环境解决方案应运而生。这个方案需要两个工具：1. create-react-native-app 2. Expo。 create-react-native-app这是一款用来创建 ReactNative 项目的脚手架工具。特点是无需配置繁杂的 Android 或 IOS 开发环境，便可进行原生应用的开发，极大简化了环境搭建与配置的过程，很适合学习使用。 [参考文档] https://reactnative.cn/docs/getting-started.html [替代方案] https://facebook.github.io/react-native/docs/getting-started.html 安装12345# 安装npm install -g create-react-native-app# 检测，文档更新时最新版本2.0.2create-react-native-app --version 使用123456# 创建项目create-react-native-app projectName# 启动项目cd projectNameexpo start Expo这是一款安装在手机上的应用，专门负责运行上述方式构建的 App，这有点像是微信里面运行的小程序。IOS 可以到 AppStore 里面搜索下载，Android 可以到 GooglePlay 里面搜索下载，也可以到 Github 里下载。 [Github] https://github.com/expo/expo 真机运行准备工作：使用create-react-native-app创建一个项目，然后手机安装Expo应用，并确保手机与开发机处于同一局域网下。 项目运行：npm start启动项目，打开Expo应用，使用里面的扫一扫功能，扫描项目启动后生成的巨大二维码，等待JS打包传输完毕，就会在手机上运行。 IP错误问题因为开发机可能会有多个ip地址，比如以太网IP、虚拟IP、无线局域网IP等等。当项目启动时通常会无脑的选择IP列表中的第一个，假如是以太网IP，那么就与手机所处的无线局域网不同，造成网络连接失败。 下面是这种情况的图例，项目启动时使用的是IP列表中的第一个94 IP，并没有使用无线局域网IP。 如果发生这种情况，先Ctrl+C停掉项目，设置一个环境变量，然后再重启项目即可。 [参考解决方案] https://github.com/react-community/create-react-native-app/blob/d01ddabb634532200629c6d17f920eb856fa6416/react-native-scripts/template/README.md#environment-variables [参考解决方案] https://github.com/react-community/create-react-native-app/issues/270 12345# 设置环境变量set REACT_NATIVE_PACKAGER_HOSTNAME=my-custom-ip-address-or-hostname# 重启项目npm start 开发初体验 在项目根目录下有个 App.js , 是应用的根组件, 我们手机上看到的内容就是这个组件实现的 尝试修改 App.js 中的文本内容, 然后手机摇一摇, 点击 Reload 选项即可更新修改内容 也可尝试给文本添加新的样式 12345678910111213141516171819202122232425import React from 'react';import &#123; StyleSheet, Text, View &#125; from 'react-native';// 导出根组件, 组件的定于语法与之前学习的一样export default class App extends React.Component &#123; render() &#123; return ( // 返回的视图需要使用View组件包裹, 作用相当于Div标签 &lt;View style=&#123;styles.container&#125;&gt; &#123;/* 文本内容使用Text组件包裹, 作用相当于P标签 */&#125; &lt;Text&gt;Open up App.js to start working on your app!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;// 定义样式, 这里的尺寸大小无需加单位, 元素可以通过数组引用多个样式, 后面的样式优先级比前面的高const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: '#fff', alignItems: 'center', justifyContent: 'center', &#125;,&#125;); 错误提示 - 红屏和黄屏RN代码运行时会把错误分为红屏和黄屏两种，红屏会以全屏红色显示在应用中，导致程序无法正常运行，红屏通常是编码错误导致的，必须修复。 黄屏代表警告，会显示在应用下方，不影响程序运行，不修复也可以，警告可以通过代码禁止。 红屏和黄屏只在debug版本中才会显示，在rellease版本中不会。一般情况下，通过RN红屏中的错误提示信息，就可以定位问题，如果是语法等常见运行错误，RN也会给出错误代码所在位置与行数，所以出现红屏一定要阅读描述信息。 123456// 频闭黄色警告，参数为一个数组：数组中的字符串就是要屏蔽的警告的开头的内容。YellowBox.ignoreWarnings(['Warning: ']);// 手动触发红屏和警告console.error("严重错误");console.warn("警告"); 调试菜单React-Native开发调试没有本地代码方便，但也是可以调的，在调试菜单中可以进行开发调试相关的配置。调试菜单只在debug版本中可以被调出，如果是模拟器环境，Windows平台按window+m可调出，也可能是F1或F2，Mac平台按commond+m可调出，或者发送adb shell input keyevent 82指令。如果是真机，摇一摇就可以调出调试菜单。 调试菜单说明 Reload: 重新加载整个页面 Debug JS Remotely: 启动远程调试, 会自动打开chrome浏览器, 然后可在开发者工具中调试js Enable Live Reload: 开启自动加载, 代码变动会自动更新整个页面 Enable Hot Reloading: 热更新, 代码变动自动的进行局部更新 Dev Sttings: 开发调试配置]]></content>
      <categories>
        <category>es6</category>
        <category>react-natives</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode二叉树]]></title>
    <url>%2F2018%2F12%2F05%2Fleetcode%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树的前序便利给定一个二叉树，返回它的 前序 遍历。 示例: 输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,2,3] 12345678910111213141516import java.util.ArrayList;class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; ArrayList&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;(); if(root==null)return res; order(root,res); return res; &#125; private static void order(TreeNode root, ArrayList&lt;Integer&gt; list)&#123; if(root != null)&#123; list.add(root.val); order(root.left,list); order(root.right,list); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode2两个链表之和]]></title>
    <url>%2F2018%2F12%2F02%2Fleetcode2%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 我的思路 这道题因为不知道链表的长度，所以在计算时不能用转换成int的方式进行计算。这样的可能会造成溢出。 加法其实就是 相同位再加进位数，进行循环就好，直到两个链表都为null，就标志着相加完成。 talk is cheap show me code 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @Author: sangfei * @Description: */public class LeetCode2 &#123; public static void main(String[] args)&#123; &#125; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; if(l1==null)&#123; return l2; &#125; if(l2==null)&#123; return l1; &#125; ListNode dummyHead=new ListNode(0); ListNode curr=dummyHead; int res=0;//进位 while (l1!=null || l2!=null)&#123; int x=(l1!=null)?l1.val:0; int y=(l2!=null)?l2.val:0; int sum=x+y+res; res=sum/10; curr.next= new ListNode(sum%10); curr=curr.next; if(l1!=null) l1=l1.next; if(l2!=null) l2=l2.next; &#125; if(res&gt;0)&#123; curr.next=new ListNode(res); &#125; return dummyHead.next; &#125;&#125; class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode[1]两数之和]]></title>
    <url>%2F2018%2F12%2F01%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[从今天开始从新学习一遍数据结构，并开始leetcode学习之旅给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。示例: 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]思路： 暴力破解时间复杂度为O(N*N) 哈希表时间复杂度为O(N)下面是我的个人写法，仅作参考。123456789101112131415public class TowSum &#123; public int[] twoSum(int[] numbers, int target) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int[] result= new int[2]; for(int i=0;i&lt;numbers.length;i++)&#123; if(map.get(target-numbers[i])!=null)&#123; result[0]= map.get(target-numbers[i])+1; result[1]=i+1; &#125;else&#123; map.put(numbers[i],i); &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动实现jquery2]]></title>
    <url>%2F2018%2F11%2F18%2F%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0jquery2%2F</url>
    <content type="text"><![CDATA[仔细看了看，上次的jquery源码不太对，jquery的作者并不是这样写的，原谅我的不仔细。这样写的话如果获取到dom元素后，在加$().css,等方法时，会造成一个极大的内存浪费。源码是这样的12345678910111213141516171819202122232425262728293031(function(global)&#123; function jQuery(selector)&#123; return new jQuery.fn.init(selector); &#125; jQuery.fn = jQuery.prototype = &#123; constructor:jQuery, init:function(selector)&#123; if(jQuery.type(selector)==="string")&#123; //选择器 const elements = document.querySelectorAll(selector) for(let i = 0;i&lt;elements.length;i++)&#123; this[i] = elements[i]; &#125; this.length=elements.length; &#125;else if( selector.nodeType )&#123; //DOM元素 this[0] = selector; this.length = 1; &#125; &#125; &#125; jQuery.fn.init.prototype = jQuery.fn; global.$ = global.jQuery = jQuery;&#125;)(window)]]></content>
      <categories>
        <category>javascript</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS日期相加减]]></title>
    <url>%2F2018%2F11%2F17%2FJS%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%8A%A0%E5%87%8F%2F</url>
    <content type="text"><![CDATA[Js中时间相加减因为有时候从后台传过来的时间，不能直接进行运算。所以我们需要进行格式转化后进行相加减。我后台的格式如下： yyyy-mm-dd hh24:mi后在前台需要进行如下转换:12345678910var dayTime=updateTime.split(" "); var day=dayTime[0].split("-"); var time=dayTime[1].split(":"); var oldTime=new Date(Number(day[0]),(Number(day[1])-1),Number(day[2]),Number(time[0]),Number(time[1]),0); var newTime= new Date(); var iDays = Math.floor((newTime - oldTime) / 86400000); if(iDays&gt;5)&#123; mx.indicate ("info", "只能撤回发布5天之内的方案！"); return; &#125; 如上是连个日期相减，日期加的话在新日期生成的时候直接在构造函数内相加。下面是日期加五天的例子：1var newime=new Date(Number(day[0]),(Number(day[1])+5),Number(day[2]),Number(time[0]),Number(time[1]),0);]]></content>
      <categories>
        <category>-Javascript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>格式转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动实现jquery]]></title>
    <url>%2F2018%2F11%2F17%2F%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0jquery%2F</url>
    <content type="text"><![CDATA[目前jQuery生存空间越来越小，但是在实际的生产项目由于历史遗留问题jquery仍然被大量使用。这几天在歇息时仔细看看了它的实现，发现里面还是有很多值得我学习的地方，对理解js基础知识以及编程思路有很大的帮助。 首先jq它为我们只提供了一个JQuery和$两个入口函数，并且在加载完后就能引用，所以最外层肯定和其他框架一样是一个立即执行函数。看代码123456(function(windown)&#123; function jQuery(selector)&#123; &#125; window.$ = window.jQuery = jQuery;&#125;)(windown) 这样就可以给用户提供一个jQuery函数了，并且把选择器当成参数传进去 函数内部拿到了选择器，接下来就要拿到 dom对象，然后改变对象的属性了。Jquery并没有在Jquery函数中直接获取，而是在另外一个函数获取。具体看代码1234567891011121314151617181920(function(window)&#123; function Fn(selector)&#123; &#125; Fn.prototype = &#123; init(selector)&#123; var elements = document.querySelectorAll(selector); for( var i = 0 ; i &lt; elements.length ; i++ )&#123; this[i] = elements[i]; this.length++; &#125; &#125;, length : 0 &#125; function jQuery(selector)&#123; return new Fn(selector) &#125; window.$ = window.jQuery = jQuery; &#125;)(window) 怎么样是不是很巧妙，这样就可以在函数内部形成高内聚和不浪费运行内存的形式。]]></content>
      <categories>
        <category>javascript</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMD和CMD]]></title>
    <url>%2F2018%2F11%2F15%2FAMD%E5%92%8CCMD%2F</url>
    <content type="text"><![CDATA[#AMD CMD，CommonJs和ES6的区别 AMDAMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出requireJS主要解决两个问题: 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长看一个使用requireJS的例子： 12345678910111213141516//定义模块MyModuledefine(['dependency'], function()&#123; var name = 'Byron'; function printName()&#123; console.log(name); &#125; return &#123; printName: printName &#125;;&#125;);// 加载模块require(['myModule'], function (my)&#123; my.printName();&#125;); 语法： requireJS定义了一个函数 define，它是全局变量，用来定义模块define(id?, dependencies?, factory);id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）dependencies：是一个当前模块依赖的模块名称数组factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值在页面上使用require函数加载模块 require([dependencies], function(){});require()函数接受两个参数第一个参数是一个数组，表示所依赖的模块第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。 CMD(Common Module Definition)淘宝团队提供，就近依赖，同步概念即用即加载模块 12345678910// 定义模块 myModule.jsdefine(function(require, exports, module) &#123; var $ = require('jquery.js') $('div').addClass('active');&#125;);// 加载模块seajs.use(['myModule.js'], function(my)&#123;&#125;); CommonJs规范，module.exprts与nodeJs采用的规范一致话不多说，上代码： 1234567exports.area=function(r)&#123; return Math.PI*r*r;&#125;exports.circumference=function(r)&#123; return 2*Math.PI*r;&#125; ES6特性 export/import成对出现，有导出才有导入 12345678910111213141516//lib.js//导出常量export const sqrt = Math.sqrt;//导出函数export function square(x) &#123; return x * x;&#125;//导出函数export function diag(x, y) &#123; return sqrt(square(x) + square(y));&#125;//main.jsimport &#123; square, diag &#125; from './lib';console.log(square(11)); // 121console.log(diag(4, 3)); // 5]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的数据交互]]></title>
    <url>%2F2018%2F11%2F01%2FJSONP%E5%92%8Curlencode%2F</url>
    <content type="text"><![CDATA[这几天在项目中用到的一些数据传输问题 ajax cors跨域cors跨域很简单，也是官方推荐的方法1response.setHeader(“Access-Control-Allow-Origin”, “*”); CORS方案实现非常简单，只要服务在头部标明允许跨域访问即可。但是这个方案由于推出时间较晚，所以IE9及以下浏览器并没有支持这个机制。IE9及以下浏览器在安全设置里控制是否允许跨域数据访问： JOSNPjosnp 属于民间开发者自己搞的方法，其原理是 动态创建srcipt标签支持目前所有浏览器，只是在实现方式上需要前后端代码有一点约定配合。但是，要注意由于JSONP是以script标签的src属性加载的，因此参数会收到URL长度的限制，只能适用于传入参数内容不多的场景。典型应用：百度搜索输入框获取下拉框 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; function show(data)&#123; alert(data.s); &#125; window.onload=function()&#123; let oTxt= document.getElementById("in"); oTxt.oninput=function()&#123; let secrpt= document.createElement('script'); secrpt.src=`https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=$&#123;encodeURIComponent(oTxt.value)&#125;&amp;cb=show` document.head.appendChild(secrpt); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" name="" id="in"&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Javascript</category>
        <category>数据交互</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>XHR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win-server升级mysql]]></title>
    <url>%2F2018%2F10%2F13%2Fwin-server%E5%8D%87%E7%BA%A7mysql%2F</url>
    <content type="text"><![CDATA[先备份原来的数据库在mysql的安装目录下 cd bin执行:mysqldump -uroot -p –all-databases &gt; sqlfile.sql输入密码:可以在bin目录下找到sqlfile.sql文件，保存该文件。 安装1.下载地址：https://dev.mysql.com/downloads/mysql/5.7.html#2.下载后可以把解压的内容随便放到一个目录，我的是如下目录（放到C盘的话，可能在修改ini文件时涉及权限问题，之后我就改放E盘了）：E:\mysql如下图：此时加压后的文件中没有data目录和ini文件3.在E:\mysql目录下新建my.ini文件，复制如下内容[mysqld]设置3306端port = 3306设置mysql的安装目录basedir=E:\mysql设置mysql数据库的数据的存放目录datadir=E:\mysql\data允许最大连接数max_connections=200服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8创建新表时将使用的默认存储引擎default-storage-engine=INNODBsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES[mysql]设置mysql客户端默认字符集default-character-set=ut]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js闭包]]></title>
    <url>%2F2018%2F10%2F10%2Fjs%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[12345678910function a()&#123; var i=0; function b()&#123; console.log(++i); &#125; return b;&#125;var c=a();c(); 这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b，就是说：当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。 闭包的作用 在a执行完后并返回，闭包使得JavaScript的垃圾回收机制GC不会收回a所占的资源，因为a的内部函数b的执行需要依赖a中的变量下面是一个经典的闭包利用12345678910111213for(var j=0;j&lt;5;j++)&#123; (function(j)&#123; setTimeout(function()&#123; console.log(j); &#125;,1000); &#125;)(j)&#125;console.log(`--------------`);for(var i=0;i&lt;=5;i++)&#123; ((i)=&gt;&#123;setTimeout(()=&gt; console.log(i),1000); &#125;)(i);&#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动实现ajax]]></title>
    <url>%2F2018%2F08%2F06%2F%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0ajax%2F</url>
    <content type="text"><![CDATA[代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function ajax(option)&#123; option=option||&#123;&#125;; option.type=option.type||'get'; option.data=option.data||&#123;&#125;; option.dataType=option.dataType||'text'; let xhr=new XMLHttpRequest(); let arr=[]; for(let name in option.data)&#123; arr.push(`$&#123;encodeURIComponent(name)&#125;=$&#123;encodeURIComponent(option.data[name])&#125;`); &#125; let strData=arr.join('&amp;'); if(option.type=='post')&#123; xhr.open('POST',option.url,true); xhr.setRequestHeader('content-type','application/x-www-form-urlencoded'); xhr.send(strData); &#125;else&#123; xhr.open('GET',option.url+'?'+strData,true); xhr.send(); &#125; //接收 xhr.onreadystatechange=()=&gt;&#123; if(xhr.readyState==4)&#123; if(xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300 ||xhr.status==304)&#123; let data=xhr.responseText; switch(option.dataType)&#123; case 'json': if(window.JSON &amp;&amp; JSON.parse)&#123; data=JSON.parse(data); &#125;else&#123; data=eval('('+str+')'); &#125; break; case 'xml': data=xhr.responseXML; break; &#125; option.success &amp;&amp; option.success(data); &#125;else&#123; options.error &amp;&amp; options.error(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Javascript</category>
        <category>数据交互</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>XHR</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
</search>
